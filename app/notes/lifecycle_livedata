Lifecycle
LifecycleObserver:生命周期观察者，观察activity或者fragment的生命周期，在生命周期发生变化时候处理自己的业务。实现了次接口的类，都能感应生命周期
Lifecycle：被观察者，存储实现了LifecycleObserver的观察者。子类LifecycleRegistry默认会在activity或者fragment初始化时候创建。
LifecycleOwner:Lifecycle拥有者，只有一个方法@NonNull Lifecycle getLifecycle();通常是activity或者fragment
onCreate,onStart,onResume会先调用自身的方法，再调用LifecycleObserver的方法。
onPause,onStop,onDestroy会先调用LifecycleObserver的方法，然后再调用自身的方法。

LiveData:
LiveData observe必须放在主线程调用，否则会抛出异常，注册观察者的时候会传入LifecycleOwner，这样livedata就能感知activity或fragment的生命周期。
setValue()必须再主线程中调用,postValue一般用在子线程中调用

同一个LiveData，观察多个owner，后注册的owner也能收到通知。

更改livedata中的数据
如果我们想要在LiveData对象分发给观察者之前对其中存储的值进行更改，可以使用Transformations.map()
  val map: LiveData<Int> = Transformations.map(mutableLiveData) {
            33
        }
Fuction 函数返回的是另一个值，map返回的是livedata

Transformations.switchMap 如果想要手动控制监听其中一个的数据变化，并能根据需要随时切换监听，这时可以使用Transformations.switchMap()，
它和Transformations.map()使用方式类似，只不过switchMap()必须返回一个LiveData对象。
var transformSwitchMap: LiveData<String> = Transformations.switchMap(mutableLiveData, Function {
            LogUtils.d("switchMap $it")
            MutableLiveData<String>(it + "transform")
        })
  Fuction 函数返回的是一个livedata对象


合并多个LiveData数据,MediatorLiveData
 val mutableLiveData1 = MutableLiveData<String>()
 MediatorLiveData.addSource(mutableLiveData1) {
            LogUtils.d("mutableLiveData1 $it")

        }
当mutableLiveData1 post数据的时候MediatorLiveData 也能收到。






